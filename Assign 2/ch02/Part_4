import numpy as np
import matplotlib.pyplot as plt

# Load rectangle.data
data = []
with open('rectangle.data', 'r') as f:
    for line in f:
        parts = [float(x) for x in line.replace(',', ' ').split()]
        data.append(parts)
data = np.array(data)
X = data[:, :3]
y = data[:, 3]

# AdalineGD implementation
class AdalineGD:
    def __init__(self, eta=0.01, n_iter=10):
        self.eta = eta
        self.n_iter = n_iter
    def fit(self, X, y, w_init, b_init):
        self.w_ = np.array(w_init)
        self.b_ = b_init
        self.cost_ = []
        for _ in range(self.n_iter):
            net_input = np.dot(X, self.w_) + self.b_
            errors = y - net_input
            self.w_ += self.eta * X.T.dot(errors)
            self.b_ += self.eta * errors.sum()
            cost = (errors**2).mean()
            self.cost_.append(cost)
        return self

# Initial values
w_init = [0.25, -0.125, 0.0625]
b_init = 0.0
ada = AdalineGD(eta=0.01, n_iter=10)
ada.fit(X, y, w_init, b_init)

# Plot MSE evolution
plt.figure(figsize=(7,5))
plt.plot(range(1, 11), ada.cost_, marker='o')
plt.title('AdalineGD Mean Squared Error (Rectangle Data)')
plt.xlabel('Epochs')
plt.ylabel('Mean Squared Error')
plt.grid(True)
plt.show()

# Final weights, bias, and accuracy
print("Final weights:", ada.w_)
print("Final bias:", ada.b_)
preds = (np.dot(X, ada.w_) + ada.b_ >= 0.5).astype(int)
accuracy = (preds == y).mean()
print("Training accuracy:", accuracy)

import numpy as np

# Load rectangle.data
data = []
with open('rectangle.data', 'r') as f:
    for line in f:
        parts = [float(x) for x in line.replace(',', ' ').split()]
        data.append(parts)
data = np.array(data)
X = data[:, :3]
y = data[:, 3]

# AdalineGD implementation
class AdalineGD:
    def __init__(self, eta=0.01, n_iter=10):
        self.eta = eta
        self.n_iter = n_iter
    def fit(self, X, y, w_init, b_init):
        self.w_ = np.array(w_init)
        self.b_ = b_init
        self.cost_ = []
        for epoch in range(self.n_iter):
            net_input = np.dot(X, self.w_) + self.b_
            errors = y - net_input
            self.w_ += self.eta * X.T.dot(errors)
            self.b_ += self.eta * errors.sum()
            cost = (errors**2).mean()
            self.cost_.append(cost)
            print(f"Epoch {epoch+1}, MSE: {cost:.4f}")  # Print MSE at each epoch
        return self

# Initial values
w_init = [0.25, -0.125, 0.0625]
b_init = 0.0
ada = AdalineGD(eta=0.01, n_iter=10)
ada.fit(X, y, w_init, b_init)

